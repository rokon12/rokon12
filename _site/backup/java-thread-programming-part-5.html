<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="canonical" href="https://bazlur.ca/2021/11/02/java-thread-programming-part-5/"><title>Java Thread Programming (Part 5) | Bazlur’s Blog Archive</title><meta name="generator" content="Jekyll v3.9.5" /><meta property="og:title" content="Java Thread Programming (Part 5)" /><meta name="author" content="A N M Bazlur Rahman" /><meta property="og:locale" content="en_US" /><meta name="description" content="A comprehensive archive of articles on Java, Software Development, and Technology" /><meta property="og:description" content="A comprehensive archive of articles on Java, Software Development, and Technology" /><link rel="canonical" href="http://localhost:4000/backup/java-thread-programming-part-5.html" /><meta property="og:url" content="http://localhost:4000/backup/java-thread-programming-part-5.html" /><meta property="og:site_name" content="Bazlur’s Blog Archive" /><meta property="og:image" content="http://localhost:4000/assets/img/default-og.jpg" /><meta property="og:type" content="website" /><meta name="twitter:card" content="summary" /><meta property="twitter:image" content="http://localhost:4000/assets/img/default-og.jpg" /><meta property="twitter:title" content="Java Thread Programming (Part 5)" /><meta name="twitter:site" content="@bazlur_rahman" /><meta name="twitter:creator" content="@A N M Bazlur Rahman" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"A N M Bazlur Rahman","url":"https://bazlur.ca"},"description":"A comprehensive archive of articles on Java, Software Development, and Technology","headline":"Java Thread Programming (Part 5)","image":"http://localhost:4000/assets/img/default-og.jpg","url":"http://localhost:4000/backup/java-thread-programming-part-5.html"}</script><style> /* Critical CSS - Inline for faster initial render */ :root { --primary-color: #2563eb; --secondary-color: #7c3aed; --text-color: #1f2937; --text-light: #6b7280; --bg-color: #ffffff; --bg-gray: #f9fafb; } * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; line-height: 1.6; color: var(--text-color); background: var(--bg-gray); } .wrapper { max-width: 1200px; margin: 0 auto; padding: 0 2rem; } header { background: var(--bg-color); box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: sticky; top: 0; z-index: 100; } .site-nav { display: flex; justify-content: space-between; align-items: center; padding: 1rem 0; } .site-title { font-size: 1.5rem; font-weight: 700; color: var(--primary-color); text-decoration: none; } .nav-links { display: flex; gap: 2rem; list-style: none; } .nav-links a { color: var(--text-color); text-decoration: none; transition: color 0.2s; } .nav-links a:hover { color: var(--primary-color); } /* Above-the-fold home page styles */ .banner-container { margin: 2rem auto 3rem; text-align: center; } .ascii-banner { display: inline-block; font-family: 'JetBrains Mono', monospace; font-size: 11px; line-height: 1.2; color: var(--primary-color); } @media (max-width: 768px) { .wrapper { padding: 0 1rem; } .ascii-banner { font-size: 6px; } .nav-links { gap: 1rem; } }</style><link rel="preload" href="/assets/css/main.css?v=2" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css?v=2"></noscript><link rel="alternate" type="application/rss+xml" title="Bazlur&#39;s Blog Archive" href="/feed.xml"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet"><body><header class="site-header"><div class="header-wrapper"> <a class="site-title" href="/">Bazlur&#39;s Blog Archive</a> <button class="mobile-menu-toggle" aria-label="Toggle menu" aria-expanded="false"> <span class="hamburger"> <span></span> <span></span> <span></span> </span> </button><nav class="site-nav"> <a class="nav-link" href="/">Home</a> <a class="nav-link" href="/archive">Archive</a> <a class="nav-link" href="/tags">Tags</a> <a class="nav-link" href="/search">Search</a> <a class="nav-link" href="https://bazlur.com/conference/" target="_blank" rel="noopener">Speaking</a> <a class="nav-link" href="/about">About</a> <a class="nav-link nav-link-external" href="https://bazlur.ca" target="_blank" rel="noopener">Original Site →</a></nav></div></header><main class="page-content" aria-label="Content"><h1 id="java-thread-programming-part-5">Java Thread Programming (Part 5)</h1><p>In <a href="https://foojay.io/today/java-thread-programming-part-4/">our previous article</a>, we discussed the “data race” concept and how we can solve it using volatile keywords. However, this is not the only problem we face when dealing with code that runs in multi-threaded environments. In this article, we will discuss another situation called “race conditions” and how we can resolve it.</p><p>By now, we know that threads share memory space so that multiple threads can read from and write to the same variable. Unfortunately, although this ability gives us faster memory access, it has an unpleasant side effect which we call “race condition,” and it creates data inconsistency in the program. To understand the problem, let’s see an example.</p><p>In the following code, we will try to simulate a bank account. We will keep debiting and crediting the same amount from two different threads from an account. The idea is, if we debit and credit the same amount multiple times, the net result should remain the same.</p><pre><code>package com.bazlur;

public class BankAccount {
    private long balance;

    public BankAccount(long balance) {
        this.balance = balance;
    }

    public void withdraw(long amount) {
        long newBalance = this.balance - amount;
        this.balance = newBalance;
    }

    public void deposit(long amount) {
        long newBalance = this.balance + amount;
        this.balance = newBalance;
    }

    @Override
    public String toString() {

        return String.valueOf(balance);
    }
}
</code></pre><p>The above class is a super simple Java class. It has two methods. One deposits an amount, and the other withdraws an amount from a bank account. The balance variable is that from where we do read the value from and write to.</p><p>Let’s use this class in a multi-threaded code.</p><blockquote><p>Tangent: We started two threads from the main method. One main method starts the two threads, and then it dies. The other two threads keep running. We need to print the balance value once these two threads finish their work, and we can do that from the main method. The problem is that the main thread already died at this point. We can keep the main thread waiting until the other two threads die using <code>Thread.join()</code> method call. Once both threads are finished, the main thread print the value and then exit.</p></blockquote><p>In the above code, in the main method, we have created an instance of the <code>BankAccount</code> class with an initial balance, 100. Then we have created two threads, one does deposit, and the other one does withdraw. Both of them do this operation inside a loop, more precisely 1000 times.</p><p>The expectation is that if both threads run the code, the net result of the balance should remain the same as the initial balance.</p><p>Unfortunately, that’s not the case. When we run it, we get a different result each time. Sometimes it’s negative, and other times it’s positive, but not precisely to the initial balance.</p><p>Can we solve this problem by declaring the balance variable <code>volatile</code>? The answer is no. Volatile keywords solve the visibility problem, but the situation we are dealing with now isn’t that.</p><p>Let’s put our program into a symbol and pseudocode table-</p><table><thead><tr><th>Thread 1<th>Thread 2<tbody><tr><td>1.1 L1 = S.X + 100<td>2.1 L2 = S.X- 100<tr><td>1.2 S.X = L1<td>2.2 S.X = L2</table><p>So we have several execution orders here. However, only the following execution order would maintain the accuracy of the calculation.</p><pre><code>Execution Order: 1.1, 1.2. 2.1, 2.2
Execution Order 2: 2.1, 2.2, 1.1, 1.2
</code></pre><p>But we can not guaranty that the execution order would only be the these two.</p><p>What if the execution order is the following:</p><pre><code>Execution Oder: 1.1, 2.1, 2.2, 1.2
</code></pre><p>If the code is executed with the above order, the output will not be what we expect.</p><p>The variable balance is shared in both threads. When a thread changes/updates the variable, two things happen: it reads and then writes.</p><p>If a thread reads before another thread finishes its writing, that’s where things go out of the way.</p><p>It starts with 1.1, after exacuting this line, the local variable becomes 100 + 100, which is 200. 2.1 starts immediately after it, so the first thread doesn’t get a chance to update the value to the balance variable yet. Line 2.1, the thread read the value from the balance variable, subtract 100 from it and keep the result in the local variable, which is now 0. 2.2 update the value to the balance variable. And then, when 1.2 executes, the local variable here is 200, and it updates the balance variable with it.</p><p><img src="/backup/images/threading-432x510.png" alt="" /></p><p>And this is how it produces an incorrect result.</p><p>The only way we can fix this problem is if the thread executes the write operation automatically. While it’s doing it, no other thread can read it until it finishes the operations.</p><p>The answer to the problem is, creating a mutual exclusion between the thread. Let me give you a practical example- When we go to the washroom, we lock the facilities so that one else can use it at the time. However, when one finishes using facilities, someone else can use it. The idea of a lock can be used here. When a thread reads and writes a shared variable, we have to guard that variable a lock so no other thread can access it before it unlocks it.</p><blockquote><p>The area in the code that reads from and writes to a variable, called critical sections. If the code section doesn’t execute atomically, then there is a possibility of happening race condition. Race conditions can be prevented by keeping critical inside a synchronized block.</p></blockquote><p>Achieving this mutual exclusion in Java is pretty straightforward. The trick is to use the<code>synchronized</code> keyword with a lock object. For example, if we rewrite our <code>BankAccount</code> class as follows, then the problem will go away.</p><p>When a thread acquires the lock object, no other thread will be able to use this lock. Once a thread unlocks the lock, other threads than the original thread can acquire it again. That means the critical section of the code will now be executed automatically.</p><pre><code>package com.bazlur;

public class BankAccount {
    private long balance;
    private final Object lock = new Object();

    public BankAccount(long balance) {
        this.balance = balance;
    }

    public void withdraw(long amount) {
        synchronized (lock) {
            System.out.println("Acquired Lock: " + Thread.currentThread());
            long newBalance = this.balance - amount;
            this.balance = newBalance;
            System.out.println("Unlocked the lock: " + Thread.currentThread());
        }

    }

    public synchronized void deposit(long amount) {
        synchronized (lock) {
            System.out.println("Acquired Lock: " + Thread.currentThread());
            long newBalance = this.balance + amount;
            this.balance = newBalance;
            System.out.println("Unlocked the lock: " + Thread.currentThread());
        }

    }

    @Override
    public String toString() {

        return String.valueOf(balance);
    }
}
</code></pre><p>if you run the main method again, the output would be consistent.</p><p>The other way is that every Java object has an intrinsic lock in it. It is called “monitor lock” as well. If we add the synchronized keyword in the method signature, it uses the intrinsic lock. Example:</p><pre><code>package com.bazlur;

public class Counter {
    private int count;

    public synchronized void increment() {
        this.count = this.count + 1;
    }

    public int getCount() {
        return count;
    }
}
</code></pre><p>Now let’s summarize what we have just learned from this discussion and a few more essential notes:</p><ul><li>A variable is shared among multiple threads, and when one of them writes to the variable, then that’s a critical section.<li>The critical section has to be guarded by a lock. Otherwise, a race condition will happen.<li>We can use synchronized keywords. Any object can be used as a lock in Java. However, every object has an intrinsic lock or a monitor lock in it. If we use a synchronized keyword in the method signature, then the intrinsic lock is used.<li>The synchronized block works as an atomic operation, even if it has more than one statement.<li>If we use a synchronized block over a critical section, the shared variable does not need to use a volatile keyword. The synchronize keyword itself removes the visibility problem. That means the variable is always read from or written to main memory.</ul><p>That’s all for today!</p><hr /><h3 id="discover-more-from-a-n-m-bazlur-rahman">Discover more from A N M Bazlur Rahman</h3><p>Subscribe to get the latest posts sent to your email.<br /> Type your email… {#subscribe-email}</p><p>Subscribe {#subscribe-submit}</p></main><footer class="site-footer"><div class="footer-content"><p>A comprehensive archive of articles on Java, Software Development, and Technology</p><p>© 2025 A N M Bazlur Rahman. All articles are archived from <a href="https://bazlur.ca">bazlur.ca</a></p><p> <a href="/feed.xml">RSS Feed</a> • <a href="https://twitter.com/bazlur_rahman">Twitter</a> • <a href="https://github.com/rokon12">GitHub</a></p></div></footer><script> // Fade-in animations on scroll document.addEventListener('DOMContentLoaded', function() { const observerOptions = { threshold: 0.1, rootMargin: '0px 0px -100px 0px' }; const observer = new IntersectionObserver(function(entries) { entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); } }); }, observerOptions); // Observe fade-in elements document.querySelectorAll('.fade-in, .fade-in-up, .fade-in-left, .fade-in-right, .stagger-animation').forEach(el => { observer.observe(el); }); // Add fade-in classes to post cards document.querySelectorAll('.post-card').forEach((card, index) => { card.classList.add('fade-in-up'); card.style.transitionDelay = `${index * 0.1}s`; }); // Removed duplicate image observer - handled by image-optimization.js }); </script> <script defer src="/assets/js/terminal.js"></script> <script defer src="/assets/js/image-optimization.js"></script> <script> if ('loading' in HTMLImageElement.prototype) { const images = document.querySelectorAll('img[loading="lazy"]'); images.forEach(img => { img.src = img.dataset.src || img.src; }); } else { // Fallback for browsers that don't support lazy loading const script = document.createElement('script'); script.src = 'https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js'; document.body.appendChild(script); } </script> <script> document.addEventListener('DOMContentLoaded', function() { // Mobile menu toggle const mobileMenuToggle = document.querySelector('.mobile-menu-toggle'); const siteNav = document.querySelector('.site-nav'); if (mobileMenuToggle) { mobileMenuToggle.addEventListener('click', function() { const isExpanded = this.getAttribute('aria-expanded') === 'true'; this.setAttribute('aria-expanded', !isExpanded); siteNav.classList.toggle('is-active'); document.body.classList.toggle('menu-open'); }); // Close menu when clicking outside document.addEventListener('click', function(e) { if (!e.target.closest('.site-header') && siteNav.classList.contains('is-active')) { mobileMenuToggle.setAttribute('aria-expanded', 'false'); siteNav.classList.remove('is-active'); document.body.classList.remove('menu-open'); } }); } // Initialize theme const savedTheme = localStorage.getItem('theme') || 'dark'; document.documentElement.setAttribute('data-theme', savedTheme); // Global search shortcut document.addEventListener('keydown', function(e) { // Focus search with / if (e.key === '/' && !e.metaKey && !e.ctrlKey) { const searchInput = document.querySelector('.quick-search-input') || document.querySelector('#search-input'); if (searchInput && document.activeElement !== searchInput) { e.preventDefault(); searchInput.focus(); document.body.classList.add('search-focused'); } } // Clear focus on ESC if (e.key === 'Escape') { const searchInput = document.querySelector('.quick-search-input') || document.querySelector('#search-input'); if (searchInput && document.activeElement === searchInput) { searchInput.blur(); searchInput.value = ''; document.body.classList.remove('search-focused'); } } }); }); </script> <button class="back-to-top" id="back-to-top" aria-label="Back to top"> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline> </svg> </button> <script> document.addEventListener('DOMContentLoaded', function() { const backToTopButton = document.getElementById('back-to-top'); // Show/hide button based on scroll position function toggleBackToTop() { if (window.scrollY > 300) { backToTopButton.classList.add('visible'); } else { backToTopButton.classList.remove('visible'); } } // Throttle scroll events let isScrolling = false; window.addEventListener('scroll', function() { if (!isScrolling) { window.requestAnimationFrame(function() { toggleBackToTop(); isScrolling = false; }); isScrolling = true; } }); // Smooth scroll to top backToTopButton.addEventListener('click', function() { window.scrollTo({ top: 0, behavior: 'smooth' }); }); // Initial check toggleBackToTop(); }); </script> <script> if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/sw.js').then(function(registration) { console.log('ServiceWorker registration successful'); }, function(err) { console.log('ServiceWorker registration failed: ', err); }); }); } </script>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="canonical" href="https://bazlur.ca/2022/02/01/java-thread-programming-part-12/"><title>Java Thread Programming (Part 12) | Bazlur’s Blog Archive</title><meta name="generator" content="Jekyll v3.9.5" /><meta property="og:title" content="Java Thread Programming (Part 12)" /><meta name="author" content="A N M Bazlur Rahman" /><meta property="og:locale" content="en_US" /><meta name="description" content="A comprehensive archive of articles on Java, Software Development, and Technology" /><meta property="og:description" content="A comprehensive archive of articles on Java, Software Development, and Technology" /><link rel="canonical" href="http://localhost:4000/backup/java-thread-programming-part-12.html" /><meta property="og:url" content="http://localhost:4000/backup/java-thread-programming-part-12.html" /><meta property="og:site_name" content="Bazlur’s Blog Archive" /><meta property="og:image" content="http://localhost:4000/assets/img/default-og.jpg" /><meta property="og:type" content="website" /><meta name="twitter:card" content="summary" /><meta property="twitter:image" content="http://localhost:4000/assets/img/default-og.jpg" /><meta property="twitter:title" content="Java Thread Programming (Part 12)" /><meta name="twitter:site" content="@bazlur_rahman" /><meta name="twitter:creator" content="@A N M Bazlur Rahman" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"A N M Bazlur Rahman","url":"https://bazlur.ca"},"description":"A comprehensive archive of articles on Java, Software Development, and Technology","headline":"Java Thread Programming (Part 12)","image":"http://localhost:4000/assets/img/default-og.jpg","url":"http://localhost:4000/backup/java-thread-programming-part-12.html"}</script><style> /* Critical CSS - Inline for faster initial render */ :root { --primary-color: #2563eb; --secondary-color: #7c3aed; --text-color: #1f2937; --text-light: #6b7280; --bg-color: #ffffff; --bg-gray: #f9fafb; } * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; line-height: 1.6; color: var(--text-color); background: var(--bg-gray); } .wrapper { max-width: 1200px; margin: 0 auto; padding: 0 2rem; } header { background: var(--bg-color); box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: sticky; top: 0; z-index: 100; } .site-nav { display: flex; justify-content: space-between; align-items: center; padding: 1rem 0; } .site-title { font-size: 1.5rem; font-weight: 700; color: var(--primary-color); text-decoration: none; } .nav-links { display: flex; gap: 2rem; list-style: none; } .nav-links a { color: var(--text-color); text-decoration: none; transition: color 0.2s; } .nav-links a:hover { color: var(--primary-color); } /* Above-the-fold home page styles */ .banner-container { margin: 2rem auto 3rem; text-align: center; } .ascii-banner { display: inline-block; font-family: 'JetBrains Mono', monospace; font-size: 11px; line-height: 1.2; color: var(--primary-color); } @media (max-width: 768px) { .wrapper { padding: 0 1rem; } .ascii-banner { font-size: 6px; } .nav-links { gap: 1rem; } }</style><link rel="preload" href="/assets/css/main.css?v=2" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css?v=2"></noscript><link rel="alternate" type="application/rss+xml" title="Bazlur&#39;s Blog Archive" href="/feed.xml"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet"><body><header class="site-header"><div class="header-wrapper"> <a class="site-title" href="/">Bazlur&#39;s Blog Archive</a> <button class="mobile-menu-toggle" aria-label="Toggle menu" aria-expanded="false"> <span class="hamburger"> <span></span> <span></span> <span></span> </span> </button><nav class="site-nav"> <a class="nav-link" href="/">Home</a> <a class="nav-link" href="/archive">Archive</a> <a class="nav-link" href="/tags">Tags</a> <a class="nav-link" href="/search">Search</a> <a class="nav-link" href="https://bazlur.com/conference/" target="_blank" rel="noopener">Speaking</a> <a class="nav-link" href="/about">About</a> <a class="nav-link nav-link-external" href="https://bazlur.ca" target="_blank" rel="noopener">Original Site →</a></nav></div></header><main class="page-content" aria-label="Content"><h1 id="java-thread-programming-part-12">Java Thread Programming (Part 12)</h1><p>In our <a href="https://foojay.io/today/java-thread-programming-part-11/">previous article</a>, we introduced ThreadPool through the Executor Framework. This article will discuss the different ways we can create ThreadPool.</p><p>The Executors is a factory class, and it has a few static methods ( factory method). Let’s look at them one by one-</p><p><strong>Executors.newFixedThreadPool(int nThreads):</strong> – this method takes an argument, and with that, we can specify the number of threads we want to have. The threads it creates are called worker Threads. It doesn’t matter how many tasks we put into this ThreadPool; the number of thread will remain the same the whole lifetime of this ThreadPool. If a thread dies for some reason, it will create a new one to keep the number the same.</p><p><strong>Executors.newCachedThreadPool():</strong> This ThreadPool create threads on demand. If we add a task to the pool, there is no thread available to execute the task, it creates a new one and adds the pool. The threads are then reused for later use. However, if a thread has not been used for 60 seconds, it is terminated. Usually, this thread pool provides a significant performance boost for short-lived asynchronous tasks.</p><p><strong>Executors.newSingleThreadExecutor():</strong> This creates a single worker thread with an unbounded queue. This may sound useless, but it has certain benefits. One of them is if we use it, the programming model stays the same, in case, in future, we want to use another ThreadPool. The changes then become minimal.</p><p><strong>Executors.newScheduledThredPool(int corePoolSize):</strong> sometimes, we want to keep a task repeating or schedule on a particular time. This ThreadPool allows us to do that. It takes an argument about the number of worker threads it will keep running, even if the ThreadPool is idle. This factory method returns an instance of <strong><em>ScheduledExecutorService</em></strong>, which has a few extra methods that we can use to schedule a job. For example –</p><pre><code>import static java.time.temporal.ChronoField.HOUR_OF_DAY;
import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;

import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class Playground {
  
  public static void main(String[] args) {
    ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);

    DateTimeFormatter timeFormatter = new DateTimeFormatterBuilder()
        .appendValue(HOUR_OF_DAY, 2)
        .appendLiteral(':')
        .appendValue(MINUTE_OF_HOUR, 2)
        .optionalStart()
        .appendLiteral(':')
        .appendValue(SECOND_OF_MINUTE, 2)
        .toFormatter();

    threadPool.scheduleAtFixedRate(() -&gt; {
      System.out.print(LocalTime.now().format(timeFormatter) + "\r");
    }, 1000, 1000, TimeUnit.MILLISECONDS);
  }
}
</code></pre><p><br /></p><p>The above code will print time, and it would look like a digital watch and it will keep running until we stop it. We used the <strong>scheduleAtFixedRate()</strong> method, which takes a task as its first argument, and then it takes another two integer arguments, initial delay and period, and the unit of time. It has several other methods, which deserve a complete article only for it. So stay tuned; perhaps in the future one, I will dig deep into it.</p><p><strong>Executors.newWorkStealingPool():</strong> java 8 introduced this new ThreadPool, and it uses a particular framework called Fork/Join framework. This one also deserves a complete article, so that I will discuss it later.</p><p>Now that we have found a few ways to create our ThreadPool, how do I submit our tasks and get them done?</p><p>We have already seen that we can just put a runnable and then submit it to the pool. This works in most cases; however, sometimes, we want to get a result after executing a piece of code. We can get a result in two ways from a ThreadPool. They are through the Callable and the Future interface. Let’s discuss them one by one.</p><h4 id="callable">Callable:</h4><p>The interface looks like this.</p><pre><code>public interface Callable {

    V call() throws Exception;

}
</code></pre><p><br /></p><p>It is also a functional interface like Runnable; the only difference is that it can return a result and throw exceptions.</p><p>Let’s see an example –</p><pre><code>import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Playground {

  final static Map&lt;Integer, Long&gt; cache = new HashMap&lt;&gt;(
      Map.of(0, 0L, 1, 1L)
  );

  public static void main(String[] args) {

    ExecutorService threadPool = Executors.newCachedThreadPool();

    Future&lt;Long&gt; fibonacciNumber = threadPool.submit(new Callable&lt;Long&gt;() {
      @Override
      public Long call() throws Exception {

        return fibonacci(50);
      }
    });
  }

  private static Long fibonacci(int n) {
    return cache.computeIfAbsent(n,
        x -&gt; fibonacci(x - 1) + fibonacci(x - 2));
  }

}
</code></pre><p><br /></p><p>In the above code, we submitted a job to calculate the 50th Fibonacci number. To submit the job, we have used the callable interface. Since the interface is a functional interface, we can also use a lambda expression.</p><p><code>Future fibonacciNumber = threadPool.submit(() -&gt; fibonacci(50));</code></p><p>But look, it returns the result wrapped with another interface, Future. Let’s talk about it.</p><h4 id="future">Future:</h4><p>It has several methods:</p><pre><code>public interface Future&lt;V&gt; {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}

</code></pre><p>However, we usually use the get() and isDone() methods for most of the use cases. The idea is that when we submit a task through Callable, it immediately returns a Future. The Future will hold the result when it’s done, not immediately. That means, when we get the reference of the future, the work may not be done yet. We can check that using the isDone() method. We get the result using the get() method. We have to keep in mind that the get() method is blocking operation. The get() method is called from the thread and will be blocked until the result is computed.</p><p><img src="/backup/images/threadpool-vs-main-threads-700x421.png" alt="" /></p><p>If you look at the image, the main thread executes the green parts. A worker thread from the <strong>ThreadPool</strong> runs the area with pink colour. It turns out we call the get() method from the main thread. Thus, the main thread will be blocked until we get the result.</p><h4 id="shutting-down-the-threadpool">Shutting down the ThreadPool</h4><p>One important thing, once we have done with the ThreadPool, we must shut down the ThreadPool. There are two methods for doing that – shutdown() and shutdownNow();</p><p>The shutdown() method tells the ThreadPool that we are not supposed to take any more tasks, and once the existing tasks are done, terminate. On the other hand, the shutdownNow() method terminates the ThreadPool immediately, even if some tasks are still being executed.</p><p><br /></p><p>I hope this article gives you a glips of how we can use ThreadPool in java.</p><p>That’s all for today, cheers!</p><p><br /></p><hr /><h3 id="discover-more-from-a-n-m-bazlur-rahman">Discover more from A N M Bazlur Rahman</h3><p>Subscribe to get the latest posts sent to your email.<br /> Type your email… {#subscribe-email}</p><p>Subscribe {#subscribe-submit}</p></main><footer class="site-footer"><div class="footer-content"><p>A comprehensive archive of articles on Java, Software Development, and Technology</p><p>© 2025 A N M Bazlur Rahman. All articles are archived from <a href="https://bazlur.ca">bazlur.ca</a></p><p> <a href="/feed.xml">RSS Feed</a> • <a href="https://twitter.com/bazlur_rahman">Twitter</a> • <a href="https://github.com/rokon12">GitHub</a></p></div></footer><script> // Fade-in animations on scroll document.addEventListener('DOMContentLoaded', function() { const observerOptions = { threshold: 0.1, rootMargin: '0px 0px -100px 0px' }; const observer = new IntersectionObserver(function(entries) { entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); } }); }, observerOptions); // Observe fade-in elements document.querySelectorAll('.fade-in, .fade-in-up, .fade-in-left, .fade-in-right, .stagger-animation').forEach(el => { observer.observe(el); }); // Add fade-in classes to post cards document.querySelectorAll('.post-card').forEach((card, index) => { card.classList.add('fade-in-up'); card.style.transitionDelay = `${index * 0.1}s`; }); // Removed duplicate image observer - handled by image-optimization.js }); </script> <script defer src="/assets/js/terminal.js"></script> <script defer src="/assets/js/image-optimization.js"></script> <script> if ('loading' in HTMLImageElement.prototype) { const images = document.querySelectorAll('img[loading="lazy"]'); images.forEach(img => { img.src = img.dataset.src || img.src; }); } else { // Fallback for browsers that don't support lazy loading const script = document.createElement('script'); script.src = 'https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js'; document.body.appendChild(script); } </script> <script> document.addEventListener('DOMContentLoaded', function() { // Mobile menu toggle const mobileMenuToggle = document.querySelector('.mobile-menu-toggle'); const siteNav = document.querySelector('.site-nav'); if (mobileMenuToggle) { mobileMenuToggle.addEventListener('click', function() { const isExpanded = this.getAttribute('aria-expanded') === 'true'; this.setAttribute('aria-expanded', !isExpanded); siteNav.classList.toggle('is-active'); document.body.classList.toggle('menu-open'); }); // Close menu when clicking outside document.addEventListener('click', function(e) { if (!e.target.closest('.site-header') && siteNav.classList.contains('is-active')) { mobileMenuToggle.setAttribute('aria-expanded', 'false'); siteNav.classList.remove('is-active'); document.body.classList.remove('menu-open'); } }); } // Initialize theme const savedTheme = localStorage.getItem('theme') || 'dark'; document.documentElement.setAttribute('data-theme', savedTheme); // Global search shortcut document.addEventListener('keydown', function(e) { // Focus search with / if (e.key === '/' && !e.metaKey && !e.ctrlKey) { const searchInput = document.querySelector('.quick-search-input') || document.querySelector('#search-input'); if (searchInput && document.activeElement !== searchInput) { e.preventDefault(); searchInput.focus(); document.body.classList.add('search-focused'); } } // Clear focus on ESC if (e.key === 'Escape') { const searchInput = document.querySelector('.quick-search-input') || document.querySelector('#search-input'); if (searchInput && document.activeElement === searchInput) { searchInput.blur(); searchInput.value = ''; document.body.classList.remove('search-focused'); } } }); }); </script> <button class="back-to-top" id="back-to-top" aria-label="Back to top"> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline> </svg> </button> <script> document.addEventListener('DOMContentLoaded', function() { const backToTopButton = document.getElementById('back-to-top'); // Show/hide button based on scroll position function toggleBackToTop() { if (window.scrollY > 300) { backToTopButton.classList.add('visible'); } else { backToTopButton.classList.remove('visible'); } } // Throttle scroll events let isScrolling = false; window.addEventListener('scroll', function() { if (!isScrolling) { window.requestAnimationFrame(function() { toggleBackToTop(); isScrolling = false; }); isScrolling = true; } }); // Smooth scroll to top backToTopButton.addEventListener('click', function() { window.scrollTo({ top: 0, behavior: 'smooth' }); }); // Initial check toggleBackToTop(); }); </script> <script> if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/sw.js').then(function(registration) { console.log('ServiceWorker registration successful'); }, function(err) { console.log('ServiceWorker registration failed: ', err); }); }); } </script>
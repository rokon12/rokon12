<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="canonical" href="https://bazlur.ca/2023/08/17/thread-safe-counter-in-java-a-comprehensive-guide/"><title>Thread-Safe Counter in Java: A Comprehensive Guide | Bazlur’s Blog Archive</title><meta name="generator" content="Jekyll v3.9.5" /><meta property="og:title" content="Thread-Safe Counter in Java: A Comprehensive Guide" /><meta name="author" content="A N M Bazlur Rahman" /><meta property="og:locale" content="en_US" /><meta name="description" content="A comprehensive archive of articles on Java, Software Development, and Technology" /><meta property="og:description" content="A comprehensive archive of articles on Java, Software Development, and Technology" /><link rel="canonical" href="http://localhost:4000/backup/threadsafe-counter-in-java-a-comprehensive-guide.html" /><meta property="og:url" content="http://localhost:4000/backup/threadsafe-counter-in-java-a-comprehensive-guide.html" /><meta property="og:site_name" content="Bazlur’s Blog Archive" /><meta property="og:image" content="http://localhost:4000/assets/img/default-og.jpg" /><meta property="og:type" content="website" /><meta name="twitter:card" content="summary" /><meta property="twitter:image" content="http://localhost:4000/assets/img/default-og.jpg" /><meta property="twitter:title" content="Thread-Safe Counter in Java: A Comprehensive Guide" /><meta name="twitter:site" content="@bazlur_rahman" /><meta name="twitter:creator" content="@A N M Bazlur Rahman" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"A N M Bazlur Rahman","url":"https://bazlur.ca"},"description":"A comprehensive archive of articles on Java, Software Development, and Technology","headline":"Thread-Safe Counter in Java: A Comprehensive Guide","image":"http://localhost:4000/assets/img/default-og.jpg","url":"http://localhost:4000/backup/threadsafe-counter-in-java-a-comprehensive-guide.html"}</script><style> /* Critical CSS - Inline for faster initial render */ :root { --primary-color: #2563eb; --secondary-color: #7c3aed; --text-color: #1f2937; --text-light: #6b7280; --bg-color: #ffffff; --bg-gray: #f9fafb; } * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; line-height: 1.6; color: var(--text-color); background: var(--bg-gray); } .wrapper { max-width: 1200px; margin: 0 auto; padding: 0 2rem; } header { background: var(--bg-color); box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: sticky; top: 0; z-index: 100; } .site-nav { display: flex; justify-content: space-between; align-items: center; padding: 1rem 0; } .site-title { font-size: 1.5rem; font-weight: 700; color: var(--primary-color); text-decoration: none; } .nav-links { display: flex; gap: 2rem; list-style: none; } .nav-links a { color: var(--text-color); text-decoration: none; transition: color 0.2s; } .nav-links a:hover { color: var(--primary-color); } /* Above-the-fold home page styles */ .banner-container { margin: 2rem auto 3rem; text-align: center; } .ascii-banner { display: inline-block; font-family: 'JetBrains Mono', monospace; font-size: 11px; line-height: 1.2; color: var(--primary-color); } @media (max-width: 768px) { .wrapper { padding: 0 1rem; } .ascii-banner { font-size: 6px; } .nav-links { gap: 1rem; } }</style><link rel="preload" href="/assets/css/main.css?v=2" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css?v=2"></noscript><link rel="alternate" type="application/rss+xml" title="Bazlur&#39;s Blog Archive" href="/feed.xml"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet"><body><header class="site-header"><div class="header-wrapper"> <a class="site-title" href="/">Bazlur&#39;s Blog Archive</a> <button class="mobile-menu-toggle" aria-label="Toggle menu" aria-expanded="false"> <span class="hamburger"> <span></span> <span></span> <span></span> </span> </button><nav class="site-nav"> <a class="nav-link" href="/">Home</a> <a class="nav-link" href="/archive">Archive</a> <a class="nav-link" href="/tags">Tags</a> <a class="nav-link" href="/search">Search</a> <a class="nav-link" href="https://bazlur.com/conference/" target="_blank" rel="noopener">Speaking</a> <a class="nav-link" href="/about">About</a> <a class="nav-link nav-link-external" href="https://bazlur.ca" target="_blank" rel="noopener">Original Site →</a></nav></div></header><main class="page-content" aria-label="Content"><p><img src="/backup/images/4738b5a0-8697-4b56-aa36-d13fcb47dd8a.jpeg" alt="" /></p><h1 id="thread-safe-counter-in-java-a-comprehensive-guide">Thread-Safe Counter in Java: A Comprehensive Guide</h1><p><strong>In this tutorial, we will explore the concept of thread safety in Java, specifically focusing on a simple counter.</strong></p><p>We will start by understanding why a basic counter is not safe for multiple threads; then, we will progressively enhance its thread safety using different techniques such as synchronization, locks, Unsafe, VarHandle, and finally, AtomicInteger.</p><p>We will be referencing the code from this <a href="https://github.com/rokon12/counter">repository</a> throughout the tutorial.</p><p>Before we dive into the different implementations, let’s define a Counter interface that all our counter classes will implement.</p><p>This interface will provide a standard way to interact with the counters, regardless of their underlying implementation.</p><pre><code>public sealed interface Counter{

    void increment();

    int get();

}
</code></pre><h2 id="the-basic-counter-and-its-thread-safety-issue"><strong>The Basic Counter and Its Thread-Safety Issue</strong></h2><p>Consider a simple counter implemented in Java:</p><pre><code>public class SimpleCounter implements Counter{

    private int count = 0;

    public void increment() {

        count++;

    }

    public int getCount() {

        return count;

    }

}
</code></pre><p>This counter works perfectly in a single-threaded environment. However, when multiple threads are involved, it may not behave as expected. This is because the increment() operation is not atomic.</p><p>It involves three separate operations: reading the current value of count, incrementing this value, and writing it back to count. If two threads call increment() at the same time, they might read the same value, increment it, and write it back, effectively causing one increment to be lost.</p><p>This is a classic example of a race condition.</p><h2 id="making-the-counter-thread-safe-with-synchronization"><strong>Making the Counter Thread-Safe with Synchronization</strong></h2><p>Java provides a built-in mechanism for thread-safety: synchronization.</p><p>By declaring a method synchronized, we ensure that only one thread can execute it at a time.</p><p>Here’s how we can make our counter thread-safe using synchronization:</p><pre><code>public class SynchronizedCounter implements Counter{

    private int count = 0;

    public synchronized void increment() {

        count++;

    }

    public synchronized int getCount() {

        return count;

    }

}
</code></pre><p>Now, even if multiple threads call increment() simultaneously, each call will be executed one after the other, ensuring the correct count.</p><h2 id="enhancing-thread-safety-with-reentrantlock"><strong>Enhancing Thread-Safety with ReentrantLock</strong></h2><p>While synchronization is simple and effective, it doesn’t provide flexibility in handling lock acquisition and release. Java’s ReentrantLock gives us more control and can lead to more efficient concurrent code. Here’s our counter using a <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html">ReentrantLock</a>:</p><pre><code>package ca.bazlur;

import java.util.concurrent.locks.*;

public final class ThreadSafeCounterUsingLock implements Counter {
    private final Lock lock = new ReentrantLock();
    private int value = 0;

    @Override
    public void increment() {
        lock.lock();
        try {
            ++value;
        } finally {
            lock.unlock();
        }
    }

    @Override
    public int get() {
        lock.lock();
        try {
            return value;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre><p><strong>Advanced Techniques: Unsafe and VarHandle</strong></p><p>Java provides some advanced tools for handling concurrency. Unsafe and VarHandle are two such tools that provide low-level operations for concurrency control and memory management. However, they should be used with caution, as they can lead to complex and error-prone code.</p><p>Here’s how we can use Unsafe to implement our counter:</p><pre><code>import sun.misc.Unsafe;

public class UnsafeCounter implements Counter {

    private volatile int count = 0;

    private static final Unsafe unsafe = Unsafe.getUnsafe();

    private static final long valueOffset;

    static {

        try {

            valueOffset = unsafe.objectFieldOffset

                (UnsafeCounter.class.getDeclaredField("count"));

        } catch (Exception ex) { throw new Error(ex); }

    }

    public void increment() {

        int current;

        do {

            current = unsafe.getIntVolatile(this, valueOffset);

        } while (!unsafe.compareAndSwapInt(this, valueOffset, current, current + 1));

    }

    public int getCount() {

        return count;

    }

}


</code></pre><p>And here’s the counter using VarHandle:</p><pre><code>package ca.bazlur;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;

public final class ThreadSafeCounterUsingVarHandle implements Counter {
    private volatile int value = 0;

    @Override
    public void increment() {
        VALUE.getAndAdd(this, 1);
    }

    @Override
    public int get() {
        return value;
    }

    private final static VarHandle VALUE;

    static {
        try {
            VALUE = MethodHandles.lookup().findVarHandle(
                    ThreadSafeCounterUsingVarHandle.class, "value", int.class);
        } catch (ReflectiveOperationException e) {
            throw new Error(e);
        }
    }
}
</code></pre><h2 id="simplifying-with-atomicinteger"><strong>Simplifying with AtomicInteger</strong></h2><p>While the above methods are effective, they can be complex and hard to manage. Java provides a simpler way to handle thread-safe counters: AtomicInteger.</p><p>This class provides methods for atomically incrementing a value, which is safe to use even in a multi-threaded environment:</p><pre><code>import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCounter implements Counter{

    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {

        count.incrementAndGet();

    }

    public int getCount() {

        return count.get();

    }

}
</code></pre><p>Another example uses LongAdder, which is considered much more performant than AtomicInteger.</p><pre><code>package ca.bazlur;

import java.util.concurrent.atomic.*;

public final class LongAdderCounter implements Counter {

    private final LongAdder counter = new LongAdder();

    @Override
    public void increment() {

        counter.increment();

    }

    @Override
    public int get() {

        return counter.intValue();

    }

}
</code></pre><p>In conclusion, Java provides various methods to make a counter thread-safe, with the simplest and most efficient often being the use of high-level concurrency utilities like AtomicInteger.</p><p>However, for more complex concurrency scenarios, understanding the underlying mechanisms like synchronization, locks, Unsafe, and VarHandle is essential.</p><p>While AtomicInteger serves well in most use cases, LongAdder is highlighted as perhaps the most performant option, as indicated by basic benchmarking.</p><p>It’s worth noting that achieving accurate results through benchmarking can be challenging, so this information should be approached with caution.</p><hr /><h3 id="discover-more-from-a-n-m-bazlur-rahman">Discover more from A N M Bazlur Rahman</h3><p>Subscribe to get the latest posts sent to your email.<br /> Type your email… {#subscribe-email}</p><p>Subscribe {#subscribe-submit}</p></main><footer class="site-footer"><div class="footer-content"><p>A comprehensive archive of articles on Java, Software Development, and Technology</p><p>© 2025 A N M Bazlur Rahman. All articles are archived from <a href="https://bazlur.ca">bazlur.ca</a></p><p> <a href="/feed.xml">RSS Feed</a> • <a href="https://twitter.com/bazlur_rahman">Twitter</a> • <a href="https://github.com/rokon12">GitHub</a></p></div></footer><script> // Fade-in animations on scroll document.addEventListener('DOMContentLoaded', function() { const observerOptions = { threshold: 0.1, rootMargin: '0px 0px -100px 0px' }; const observer = new IntersectionObserver(function(entries) { entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); } }); }, observerOptions); // Observe fade-in elements document.querySelectorAll('.fade-in, .fade-in-up, .fade-in-left, .fade-in-right, .stagger-animation').forEach(el => { observer.observe(el); }); // Add fade-in classes to post cards document.querySelectorAll('.post-card').forEach((card, index) => { card.classList.add('fade-in-up'); card.style.transitionDelay = `${index * 0.1}s`; }); // Removed duplicate image observer - handled by image-optimization.js }); </script> <script defer src="/assets/js/terminal.js"></script> <script defer src="/assets/js/image-optimization.js"></script> <script> if ('loading' in HTMLImageElement.prototype) { const images = document.querySelectorAll('img[loading="lazy"]'); images.forEach(img => { img.src = img.dataset.src || img.src; }); } else { // Fallback for browsers that don't support lazy loading const script = document.createElement('script'); script.src = 'https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js'; document.body.appendChild(script); } </script> <script> document.addEventListener('DOMContentLoaded', function() { // Mobile menu toggle const mobileMenuToggle = document.querySelector('.mobile-menu-toggle'); const siteNav = document.querySelector('.site-nav'); if (mobileMenuToggle) { mobileMenuToggle.addEventListener('click', function() { const isExpanded = this.getAttribute('aria-expanded') === 'true'; this.setAttribute('aria-expanded', !isExpanded); siteNav.classList.toggle('is-active'); document.body.classList.toggle('menu-open'); }); // Close menu when clicking outside document.addEventListener('click', function(e) { if (!e.target.closest('.site-header') && siteNav.classList.contains('is-active')) { mobileMenuToggle.setAttribute('aria-expanded', 'false'); siteNav.classList.remove('is-active'); document.body.classList.remove('menu-open'); } }); } // Initialize theme const savedTheme = localStorage.getItem('theme') || 'dark'; document.documentElement.setAttribute('data-theme', savedTheme); // Global search shortcut document.addEventListener('keydown', function(e) { // Focus search with / if (e.key === '/' && !e.metaKey && !e.ctrlKey) { const searchInput = document.querySelector('.quick-search-input') || document.querySelector('#search-input'); if (searchInput && document.activeElement !== searchInput) { e.preventDefault(); searchInput.focus(); document.body.classList.add('search-focused'); } } // Clear focus on ESC if (e.key === 'Escape') { const searchInput = document.querySelector('.quick-search-input') || document.querySelector('#search-input'); if (searchInput && document.activeElement === searchInput) { searchInput.blur(); searchInput.value = ''; document.body.classList.remove('search-focused'); } } }); }); </script> <button class="back-to-top" id="back-to-top" aria-label="Back to top"> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline> </svg> </button> <script> document.addEventListener('DOMContentLoaded', function() { const backToTopButton = document.getElementById('back-to-top'); // Show/hide button based on scroll position function toggleBackToTop() { if (window.scrollY > 300) { backToTopButton.classList.add('visible'); } else { backToTopButton.classList.remove('visible'); } } // Throttle scroll events let isScrolling = false; window.addEventListener('scroll', function() { if (!isScrolling) { window.requestAnimationFrame(function() { toggleBackToTop(); isScrolling = false; }); isScrolling = true; } }); // Smooth scroll to top backToTopButton.addEventListener('click', function() { window.scrollTo({ top: 0, behavior: 'smooth' }); }); // Initial check toggleBackToTop(); }); </script> <script> if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/sw.js').then(function(registration) { console.log('ServiceWorker registration successful'); }, function(err) { console.log('ServiceWorker registration failed: ', err); }); }); } </script>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="canonical" href="https://bazlur.ca/2022/03/08/java-bytecode-simplified-journey-to-the-wonderland-part-1/"><title>Java Bytecode Simplified: Journey to the Wonderland (Part 1) | Bazlur’s Blog Archive</title><meta name="generator" content="Jekyll v3.9.5" /><meta property="og:title" content="Java Bytecode Simplified: Journey to the Wonderland (Part 1)" /><meta name="author" content="A N M Bazlur Rahman" /><meta property="og:locale" content="en_US" /><meta name="description" content="A comprehensive archive of articles on Java, Software Development, and Technology" /><meta property="og:description" content="A comprehensive archive of articles on Java, Software Development, and Technology" /><link rel="canonical" href="http://localhost:4000/backup/java-bytecode-simplified-journey-to-the-wonderland-part-1.html" /><meta property="og:url" content="http://localhost:4000/backup/java-bytecode-simplified-journey-to-the-wonderland-part-1.html" /><meta property="og:site_name" content="Bazlur’s Blog Archive" /><meta property="og:image" content="http://localhost:4000/assets/img/default-og.jpg" /><meta property="og:type" content="website" /><meta name="twitter:card" content="summary" /><meta property="twitter:image" content="http://localhost:4000/assets/img/default-og.jpg" /><meta property="twitter:title" content="Java Bytecode Simplified: Journey to the Wonderland (Part 1)" /><meta name="twitter:site" content="@bazlur_rahman" /><meta name="twitter:creator" content="@A N M Bazlur Rahman" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"A N M Bazlur Rahman","url":"https://bazlur.ca"},"description":"A comprehensive archive of articles on Java, Software Development, and Technology","headline":"Java Bytecode Simplified: Journey to the Wonderland (Part 1)","image":"http://localhost:4000/assets/img/default-og.jpg","url":"http://localhost:4000/backup/java-bytecode-simplified-journey-to-the-wonderland-part-1.html"}</script><style> /* Critical CSS - Inline for faster initial render */ :root { --primary-color: #2563eb; --secondary-color: #7c3aed; --text-color: #1f2937; --text-light: #6b7280; --bg-color: #ffffff; --bg-gray: #f9fafb; } * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; line-height: 1.6; color: var(--text-color); background: var(--bg-gray); } .wrapper { max-width: 1200px; margin: 0 auto; padding: 0 2rem; } header { background: var(--bg-color); box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: sticky; top: 0; z-index: 100; } .site-nav { display: flex; justify-content: space-between; align-items: center; padding: 1rem 0; } .site-title { font-size: 1.5rem; font-weight: 700; color: var(--primary-color); text-decoration: none; } .nav-links { display: flex; gap: 2rem; list-style: none; } .nav-links a { color: var(--text-color); text-decoration: none; transition: color 0.2s; } .nav-links a:hover { color: var(--primary-color); } /* Above-the-fold home page styles */ .banner-container { margin: 2rem auto 3rem; text-align: center; } .ascii-banner { display: inline-block; font-family: 'JetBrains Mono', monospace; font-size: 11px; line-height: 1.2; color: var(--primary-color); } @media (max-width: 768px) { .wrapper { padding: 0 1rem; } .ascii-banner { font-size: 6px; } .nav-links { gap: 1rem; } }</style><link rel="preload" href="/assets/css/main.css?v=2" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css?v=2"></noscript><link rel="alternate" type="application/rss+xml" title="Bazlur&#39;s Blog Archive" href="/feed.xml"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://cdnjs.cloudflare.com"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet"><body><header class="site-header"><div class="header-wrapper"> <a class="site-title" href="/">Bazlur&#39;s Blog Archive</a> <button class="mobile-menu-toggle" aria-label="Toggle menu" aria-expanded="false"> <span class="hamburger"> <span></span> <span></span> <span></span> </span> </button><nav class="site-nav"> <a class="nav-link" href="/">Home</a> <a class="nav-link" href="/archive">Archive</a> <a class="nav-link" href="/tags">Tags</a> <a class="nav-link" href="/search">Search</a> <a class="nav-link" href="https://bazlur.com/conference/" target="_blank" rel="noopener">Speaking</a> <a class="nav-link" href="/about">About</a> <a class="nav-link nav-link-external" href="https://bazlur.ca" target="_blank" rel="noopener">Original Site →</a></nav></div></header><main class="page-content" aria-label="Content"><p><img src="/backup/images/kenny-eliason-uecskkdb1pg-unsplash-scaled.jpg" alt="" /></p><h1 id="java-bytecode-simplified-journey-to-the-wonderland-part-1">Java Bytecode Simplified: Journey to the Wonderland (Part 1)</h1><p>There are two ways to see a thing. One, see it as it appears to us; two, see it and appreciate it. For example, we get light when we switch on a lightbulb. We press the button and then get busy with our life. Pretty simple, but boring. On the other hand, if we know how the light gets energy from an electrical power grid far from our home with wires and while travelling through the wires and filament, the filament heats up and starts emitting photons, we get to see in the light; we can then appreciate the blessing.</p><p>The same way, when we write a piece of code, and if we know the mechanism behind it, we can then appreciate it more, how excellent engineering effort went into it, making our life so amazing.</p><p>Today I will make an attempt to appreciate how unique the JVM is. So, let’s begin the journey to how Java works!</p><p>We all know that the Java compiler takes Java source and then compiles to Bytecode. The process is pretty straightforward. It takes a file and transforms it into Bytecode. The just-in-time compiler (JIT) interprets the Bytecode to machine code so that it can run. While interpreting it, it collects data, for example, how frequently a particular method is called. When a specific portion of code (in hotspot terminology, “hot code”) reaches a certain threshold, the JIT optimizes it and further compiles it to direct machine code so that it can perform better. This may seem an oversimplification, which begs for a more extensive explanation.</p><p>So in this article, we will keep it short: only one part of it, which is the Bytecode itself. What it is and its internals. It’s definitely a fun journey.</p><p>Now the first question gets to be: what is <strong>Bytecode</strong>?</p><p>If we put it simply, bytecode is a set of instructions that are emitted from the Java compiler and the JVM then executes them.</p><p>Each Bytecode is 1 byte long, and that’s why it is called Bytecode. We know there are 8 bits in a byte. That’s why there are only 2\^8 = 256 possible instructions that we could have in bytecode. Interestingly, we don’t even need the whole set of bytecode in Java. Today we use around 205. These are called operation codes or simply “opcodes”.</p><p>First, we will write a simple Java program and then compile it to see what Java compiler emits:</p><pre><code>public class Calculator {

  public int add(int a, int b) {
    return a + b;
  }
}
</code></pre><p>That’s the simplest Java program we could ever write. It’s a class with a public method, “add”, which takes two integer arguments and then returns, summing them. That’s it.</p><p>Let’s compile it.</p><pre><code>javac Calculator.java
</code></pre><p>The above command will produce a class file named “Calculator. class”. This file contains a series of bytes, and it’s not readable. You won’t be able to open it with a text file or anything.</p><p>However, an excellent Java command-line tool called “javap” allows us to read this bytecode from a class file. Let’s read them as follows:</p><pre><code>javap -c Calculator
</code></pre><p>We will get the following output if we run the above command in our terminal.</p><pre><code>Compiled from "Calculator.java"
public class Calculator {
  public Calculator();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return

  public int add(int, int);
    Code:
       0: iload_1
       1: iload_2
       2: iadd
       3: ireturn
}

</code></pre><p>Look, we can see a constructor here. However, we haven’t added that in our Java source code. Well, the Java compiler did that. That’s our default constructor. The Java compiler added it.</p><p>Let’s change gears a bit.</p><p>We know the JVM interprets byte code, and it is a stack machine. It has an operand stack. It works like <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse polish notation (RPN)</a>. For example, if we have an expression as follows:</p><p>1 + 2, then the RPN would be 1 2 +</p><p>If we want to evaluate this using the following images:</p><p><img src="/backup/images/page-272-700x250.png" alt="" /></p><p>Firstly, we will push 1 and 2 to the stack. And then, we will pop these two, add them, and put them in the stack again. The same thing is done in JVM by two instructions: <strong>iconst_&lt;&gt;</strong> and <strong>iadd</strong>.</p><p><img src="/backup/images/page-273-700x239.png" alt="" /></p><p><em>iconst_1</em> and <em>iconst_2</em> , these two opcodes push 1 and 2 to the stack, and <code>iadd</code> opcode pops them from the stack and puts them back after adding them. The <em>iconst_1</em> and <em>iconst_2</em>are two special opcodes for loading 1 and 2 as they are constant.</p><p>Let’s get back to the bytecode again.</p><p>Bytecode is nothing but a list of instructions. For example, if we want to return from the method, the bytecode would be ‘<strong>return</strong>.’</p><p>This <strong><em>return</em></strong> opcode is nothing but a representation so that we can read bytecode and reason about it. In the class file, it is just a series byte. The hex value of the return is B1, and its binary is- <em>1011 0001.</em></p><p>JVM can understand these byte series and then convert them to appropriate machine code.</p><p>Let’s see another example –</p><table><tbody><tr><td>java source code<td>opcode<td>hex<td>binary<tr><td><code>int add(int a, int b) {     return a + b; }</code><td>iload_1 <br /> iload_2 iadd ireturn<td>1B <br /> 1C 60 AC<td>0001 1011 <br /> 0001 1100 0110 0000 1010 1100</table><p>In the above table, we have a method which takes two integers arguments and then adds them. Over here, <code>a</code> and <code>b</code> are not constant; that’s why <code>iload_1</code> and <code>iload_2</code>, these two opcodes are used. The generic format of this bytecode for loading integers is: <code>iload_&lt;n&gt;</code>. It essentially means that the is an index of the array of the local variables. The parameters are, in fact, local variables. <code>iload_1</code> loads the <code>a</code> and <code>iload_2</code> loads the <code>b</code>.</p><p>Now, look at the following method:</p><pre><code>public int add() {
    return 1 + 2;
}
</code></pre><p>However, here is a caveat. If you write the above method, then compile it and try <strong>javap</strong> to read it, you will find something like this –</p><pre><code>0: iconst_3
1: ireturn
</code></pre><p>The reason is that the Java compiler does a bit of optimization; when it sees we are just adding 1 and 2 and then returning their value, it can just load the 3 into the stack with one instruction rather than using 3 instructions. We will know much more about these sorts of optimization later.</p><p>Let’s assume the Java compiler doesn’t do this little optimization in this article. The opcode, <em>iconst_1</em> and <em>iconst_2</em> will put the 1 and 2 in the stack and then use <code>iadd</code> to pop these two, add them and then put their result back to the stack and return.</p><p>That’s a brief introduction to how Java bytecode and how it looks and works. We will go a bit further in our next article.</p><p>But before closing the article, I can’t resist sharing a simple piece of Java code that can read a class file, convert it into a series of bytes, and print it out for you so you can see it the way the JVM sees it.</p><pre><code>package ca.bazlur;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class BytecodeReader {

  public static void main(String[] args) throws IOException {
    Path classfile = Path.of("src/Calculator.class");// put path of your classfile here
    byte[] bytes = Files.readAllBytes(classfile);
    for (byte aByte : bytes) {
      //ref https://stackoverflow.com/a/12310078/893197
      String byteString = String.format("%8s", Integer.toBinaryString(aByte &amp; 0xFF))
          .replace(' ', '0');
      System.out.println(byteString);
    }
  }
}
</code></pre><p>If you run this program, you will get a series of 1 and 0. Those are bits. Every 8 bits make a byte, and each byte represents an opcode. The list of all opcode can be found here:</p><p><a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions</a></p><p>That’s all for today!</p><p>Happy coding!</p><hr /><h3 id="discover-more-from-a-n-m-bazlur-rahman">Discover more from A N M Bazlur Rahman</h3><p>Subscribe to get the latest posts sent to your email.<br /> Type your email… {#subscribe-email}</p><p>Subscribe {#subscribe-submit}</p></main><footer class="site-footer"><div class="footer-content"><p>A comprehensive archive of articles on Java, Software Development, and Technology</p><p>© 2025 A N M Bazlur Rahman. All articles are archived from <a href="https://bazlur.ca">bazlur.ca</a></p><p> <a href="/feed.xml">RSS Feed</a> • <a href="https://twitter.com/bazlur_rahman">Twitter</a> • <a href="https://github.com/rokon12">GitHub</a></p></div></footer><script> // Fade-in animations on scroll document.addEventListener('DOMContentLoaded', function() { const observerOptions = { threshold: 0.1, rootMargin: '0px 0px -100px 0px' }; const observer = new IntersectionObserver(function(entries) { entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); } }); }, observerOptions); // Observe fade-in elements document.querySelectorAll('.fade-in, .fade-in-up, .fade-in-left, .fade-in-right, .stagger-animation').forEach(el => { observer.observe(el); }); // Add fade-in classes to post cards document.querySelectorAll('.post-card').forEach((card, index) => { card.classList.add('fade-in-up'); card.style.transitionDelay = `${index * 0.1}s`; }); // Removed duplicate image observer - handled by image-optimization.js }); </script> <script defer src="/assets/js/terminal.js"></script> <script defer src="/assets/js/image-optimization.js"></script> <script> if ('loading' in HTMLImageElement.prototype) { const images = document.querySelectorAll('img[loading="lazy"]'); images.forEach(img => { img.src = img.dataset.src || img.src; }); } else { // Fallback for browsers that don't support lazy loading const script = document.createElement('script'); script.src = 'https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js'; document.body.appendChild(script); } </script> <script> document.addEventListener('DOMContentLoaded', function() { // Mobile menu toggle const mobileMenuToggle = document.querySelector('.mobile-menu-toggle'); const siteNav = document.querySelector('.site-nav'); if (mobileMenuToggle) { mobileMenuToggle.addEventListener('click', function() { const isExpanded = this.getAttribute('aria-expanded') === 'true'; this.setAttribute('aria-expanded', !isExpanded); siteNav.classList.toggle('is-active'); document.body.classList.toggle('menu-open'); }); // Close menu when clicking outside document.addEventListener('click', function(e) { if (!e.target.closest('.site-header') && siteNav.classList.contains('is-active')) { mobileMenuToggle.setAttribute('aria-expanded', 'false'); siteNav.classList.remove('is-active'); document.body.classList.remove('menu-open'); } }); } // Initialize theme const savedTheme = localStorage.getItem('theme') || 'dark'; document.documentElement.setAttribute('data-theme', savedTheme); // Global search shortcut document.addEventListener('keydown', function(e) { // Focus search with / if (e.key === '/' && !e.metaKey && !e.ctrlKey) { const searchInput = document.querySelector('.quick-search-input') || document.querySelector('#search-input'); if (searchInput && document.activeElement !== searchInput) { e.preventDefault(); searchInput.focus(); document.body.classList.add('search-focused'); } } // Clear focus on ESC if (e.key === 'Escape') { const searchInput = document.querySelector('.quick-search-input') || document.querySelector('#search-input'); if (searchInput && document.activeElement === searchInput) { searchInput.blur(); searchInput.value = ''; document.body.classList.remove('search-focused'); } } }); }); </script> <button class="back-to-top" id="back-to-top" aria-label="Back to top"> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline> </svg> </button> <script> document.addEventListener('DOMContentLoaded', function() { const backToTopButton = document.getElementById('back-to-top'); // Show/hide button based on scroll position function toggleBackToTop() { if (window.scrollY > 300) { backToTopButton.classList.add('visible'); } else { backToTopButton.classList.remove('visible'); } } // Throttle scroll events let isScrolling = false; window.addEventListener('scroll', function() { if (!isScrolling) { window.requestAnimationFrame(function() { toggleBackToTop(); isScrolling = false; }); isScrolling = true; } }); // Smooth scroll to top backToTopButton.addEventListener('click', function() { window.scrollTo({ top: 0, behavior: 'smooth' }); }); // Initial check toggleBackToTop(); }); </script> <script> if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/sw.js').then(function(registration) { console.log('ServiceWorker registration successful'); }, function(err) { console.log('ServiceWorker registration failed: ', err); }); }); } </script>